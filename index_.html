<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fourier Series</title>

    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>

    <script src="lib/fourier/Fourier.js"></script>

    <style>
        body {
            background-color: black;
            text-align: center;
        }
        p {
            color: white;
        }
    </style>
</head>
<body>
    
    <p>

    </p>

    <canvas id="canvas" width="707" height="500"></canvas>
    <br>
    <button id="playButton">&#10074;&#10074;</button>
    <input id="timeline" type="range" oninput="setTime(this.value)" min="0" step="1">
    
    <script>
        var canvas = document.getElementById('canvas');
        var timeline = document.getElementById('timeline');
        var playButton = document.getElementById('playButton');
        var ctx = canvas.getContext('2d');
        
        // slider per precisione della serie di fourier

        var epicyclesColor = '#00CCFF';
        var linesColor = '#FFFFFF';
        var pathColor = '#FFFF00';

        //ctx.scale(2, 2)

        var N = 1000;

        var time = 0;
        var lastDrawnPoint = 0;
        
        var signalY = []
        var signalX = []
        
        var signalY_DFT;
        var signalX_DFT;

        var wasPlaying = false;
        timeline.onmousedown = _ => {
            wasPlaying = frameTask != -1;
            pause();
        };

        timeline.onmouseup = _ => {
            if (wasPlaying) {
                resume();
            }
        };

        playButton.onclick = () => {
            playButton.innerHTML = toggle() ? '&#9658;' : '&#10074;&#10074;'}
        
        // default path - circle
        var circle = [];
        for (var i = 0; i < 100; i++) {
            circle[i] = {
                x: 50 * Math.cos(Math.PI * 2 / 100 * i),
                y: 50 * Math.sin(Math.PI * 2 / 100 * i)
            }
        }
        setPath(circle);

        var frameTask = -1;

        resume();

        function resume() {
            frameTask = setInterval(nextFrame, 25);
        }

        function pause() {
            clearInterval(frameTask);
            frameTask = -1;
        }

        function toggle() {
            frameTask == -1 ? resume() : pause();
            return frameTask == -1;
        }

        function setPath(path) {
            signalX = [];
            signalY = [];

            // remove offset
            var minX = 999999;
            var minY = 999999;
            for (var i = 0; i < path.length; i++) {
                if (path[i].x < minX) {
                    minX = path[i].x;
                }

                if (path[i].y < minY) {
                    minY = path[i].y;
                }
            }

            for (var i = 0; i < path.length; i++) {
                signalX[i] = path[i].x - minX;
                signalY[i] = path[i].y - minY;
            }

            time = 0;
            lastDrawnPoint = 0;

            signalY_DFT = Fourier.dft(signalY);
            signalX_DFT = Fourier.dft(signalX);

            timeline.max = path.length;
        }
        
        function nextFrame() {
            if (++lastDrawnPoint >= signalX.length) {
                lastDrawnPoint = 0;
            }

            draw();
            time += 1 / signalY_DFT.length;
            // module (?)
        }

        function draw() {
            // update timeline
            timeline.value = lastDrawnPoint;

            // name these variables properly
            var a = 300;
            var b = 300;
            var c = 100;
            var d = 100;
            
            clearCanvas();
            
            var lastPointX = drawEpicycles(signalX_DFT, a, c, 0)
            var lastPointY = drawEpicycles(signalY_DFT, d, b, Math.PI * 0.5)
            
            ctx.strokeStyle = linesColor;
            ctx.beginPath();
            
            ctx.moveTo(d + lastPointY.x, b + lastPointY.y);
            // since the horizontal line oscillates vertically,
            // it gives the impression of being bigger with
            // repect to the other one.
            
            ctx.lineWidth = 0.25;
            ctx.lineTo(a + lastPointX.x, b + lastPointY.y);

            ctx.stroke();
            ctx.lineWidth = 0.5;
            ctx.lineTo(a + lastPointX.x, c + lastPointX.y);
            ctx.stroke();


            ctx.beginPath();
            //ctx.lineWidth = 1.0;
            ctx.lineWidth = 2.0;
            ctx.strokeStyle = pathColor;
            ctx.moveTo(a + signalX[0], signalY[0] + b);
            for (var i = 0; i < lastDrawnPoint; i++) {
                ctx.lineTo(a + signalX[i], signalY[i] + b);
            }
            ctx.stroke();
        }

        function setTime(point) {
            lastDrawnPoint = point;
            time = (1 / signalY_DFT.length) * (lastDrawnPoint - 1); // inc * punti

            console.log(lastDrawnPoint)

            draw();
            time += (1 / signalY_DFT.length);
        }

        function drawEpicycles(fourier, xOff, yOff, rot) {
            var x = 0;
            var y = 0;

            for (var i = 0; i < fourier.length; i++) {
                var prevX = x;
                var prevY = y;

                // precompute these values
                var freq = i;
                var ampl = Math.sqrt(fourier[i].Re * fourier[i].Re + fourier[i].Im * fourier[i].Im);                
                var phase = Math.atan2(fourier[i].Im, fourier[i].Re);

                var arg = freq * time * 2 * Math.PI + phase + rot;
                x += ampl * Math.cos(arg);
                y += ampl * Math.sin(arg);
                
                ctx.lineWidth = 1.0;
                ctx.strokeStyle = epicyclesColor;
                ctx.beginPath();
                ctx.arc(xOff + prevX, yOff + prevY, ampl, 0, Math.PI * 2);
                ctx.stroke();
               
                ctx.lineWidth = 0.5;
                ctx.strokeStyle = linesColor;
                ctx.beginPath();
                ctx.moveTo(xOff + prevX, yOff + prevY);
                ctx.lineTo(xOff + x, yOff + y);
                ctx.stroke();
            }

            return {x, y}
        }

        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        // drawable path
        var drawing = false;
        var path = [];
        canvas.onmousedown = () => {
            drawing = true;
            pause();
            clearCanvas();
            
            // show path being drawn
            ctx.beginPath();
        };
        canvas.onmouseup = () => {
            drawing = false;
            
            while (path.length > N) {
                //remove random points
                path.splice((Math.random() * path.length) | 0, 1);
            }

            if (path.length > 2) {
                setPath(path);
            }
            path = [];

            resume();
        };
        canvas.onmousemove = e => {
            if (!drawing) {
                return;
            }

            // show path being drawn
            if (path.length == 0) {
                ctx.moveTo(e.offsetX, e.offsetY);
            } else {
                ctx.lineTo(e.offsetX, e.offsetY);
                ctx.stroke();
            }

            path.push({
                x: e.offsetX,
                y: e.offsetY
            });
        };
    </script>
</body>
</html>