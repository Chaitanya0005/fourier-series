<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fourier Series</title>

    <style>
        body {
            background-color: black;
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="1414" height="1000"></canvas>

    <script>
        var canvas = document.getElementById('canvas');
        var ctx = canvas.getContext('2d');
        
        // slider per precisione della serie di fourier

        var epicyclesColor = '#00CCFF';
        var linesColor = '#FFFFFF';
        var pathColor = '#FFFF00';

        var N = 100;

        var time = 0;
        var lastDrawnPoint = 0;
        
        var signalY = []
        var signalX = []
        
        var signalY_DTF;
        var signalX_DTF;
        
        // default path - circle
        var circle = [];
        for (var i = 0; i < N; i++) {
            circle[i] = {
                x: 50 * Math.cos(Math.PI * 2 / 100 * i),
                y: 50 * Math.sin(Math.PI * 2 / 100 * i),
            }
        }
        setPath(circle);

        var frameTask;

        start();

        function start() {
            frameTask = setInterval(draw, 25);
        }

        function stop() {
            clearInterval(frameTask);
        }

        function setPath(path) {
            signalX = [];
            signalY = [];

            // remove offset
            var minX = 999999;
            var minY = 999999;
            console.log(path.length)
            for (var i = 0; i < path.length; i++) {
                if (path[i].x < minX) {
                    minX = path[i].x;
                }

                if (path[i].y < minY) {
                    minY = path[i].y;
                }
            }

            for (var i = 0; i < path.length; i++) {
                signalX[i] = path[i].x - minX;
                signalY[i] = path[i].y - minY;
            }

            time = 0;
            lastDrawnPoint = 0;

            signalY_DTF = dtf(signalY);
            signalX_DTF = dtf(signalX);

            console.log(signalX_DTF)
            console.log(signalY_DTF)
        }
        
        function draw() {
            // name these variables properly
            var a = 300;
            var b = 300;
            var c = 100;
            var d = 100;
            
            clearCanvas();
            
            var lastPointX = drawEpicycles(signalX_DTF, a, c, 0)
            var lastPointY = drawEpicycles(signalY_DTF, d, b, Math.PI * 0.5)
            
            if (++lastDrawnPoint == signalX.length) {
                lastDrawnPoint = 0;
            }
            
            ctx.strokeStyle = linesColor;
            ctx.beginPath();
            
            ctx.moveTo(d + lastPointY.x, b + lastPointY.y);
            // since the horizontal line oscillates vertically,
            // it gives the impression of being bigger with
            // repect to the other one.
            ctx.lineWidth = 0.25;
            ctx.lineTo(a + lastPointX.x, b + lastPointY.y);

            ctx.stroke();
            ctx.lineWidth = 0.5;
            ctx.lineTo(a + lastPointX.x, c + lastPointX.y);
            ctx.stroke();


            ctx.beginPath();
            ctx.lineWidth = 1.0;
            ctx.strokeStyle = pathColor;
            ctx.moveTo(a + signalX[0], signalY[0] + b);
            for (var i = 0; i < lastDrawnPoint; i++) {
                ctx.lineTo(a + signalX[i], signalY[i] + b);
            }
            ctx.stroke();

            time += Math.PI * 2 / signalY_DTF.length;
        }

        function drawEpicycles(fourier, xOff, yOff, rot) {
            var x = 0;
            var y = 0;

            for (var i = 0; i < fourier.length; i++) {
                var prevX = x;
                var prevY = y;

                var freq = i;
                var ampl = Math.sqrt(fourier[i].Re * fourier[i].Re + fourier[i].Im * fourier[i].Im);                
                var phase = Math.atan2(fourier[i].Im, fourier[i].Re);

                var arg = freq * time + phase + rot;
                x += ampl * Math.cos(arg);
                y += ampl * Math.sin(arg);
                
                ctx.lineWidth = 0.5;
                ctx.strokeStyle = epicyclesColor;
                ctx.beginPath();
                ctx.arc(xOff + prevX, yOff + prevY, ampl, 0, Math.PI * 2);
                ctx.stroke();
               
                ctx.lineWidth = 0.5;
                ctx.strokeStyle = linesColor;
                ctx.beginPath();
                ctx.moveTo(xOff + prevX, yOff + prevY);
                ctx.lineTo(xOff + x, yOff + y);
                ctx.stroke();
            }

            return {x, y}
        }

        // discrete fourier transform
        function dtf(f) {
            var fourierTransform = [];
            
            for (var k = 0; k < f.length; k++) {
                var sumRe = 0;
                var sumIm = 0;

                for (var n = 0; n < f.length; n++) {
                    var angle = 2 * Math.PI * k * n / f.length;
                    sumRe += f[n] * Math.cos(angle);
                    sumIm -= f[n] * Math.sin(angle);
                }

                fourierTransform[k] = {
                    Re: sumRe / f.length,
                    Im: sumIm / f.length,
                };
            }

            return fourierTransform;
        }

        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        // drawable path
        var drawing = false;
        var path = [];
        canvas.onmousedown = () => {
            drawing = true;
            stop();
            clearCanvas();
            
            // show path being drawn
            ctx.beginPath();
        };
        canvas.onmouseup = () => {
            drawing = false;
            
            while (path.length > N) {
                //remove random points
                path.splice((Math.random() * path.length) | 0, 1);
            }

            if (path.length > 2) {
                setPath(path);
            }
            path = [];

            start();
        };
        canvas.onmousemove = e => {
            if (!drawing) {
                return;
            }

            // show path being drawn
            if (path.length == 0) {
                ctx.moveTo(e.offsetX, e.offsetY);
            } else {
                ctx.lineTo(e.offsetX, e.offsetY);
                ctx.stroke();
            }

            path.push({
                x: e.offsetX,
                y: e.offsetY
            });
        };
    </script>
</body>
</html>